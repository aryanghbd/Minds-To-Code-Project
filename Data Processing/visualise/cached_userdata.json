{"200. Number of Islands": {"dimensions": [{"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 920}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}, {"first": 1910, "second": 910}], "memory_performance": [12.4, -1, -1, -1, -1, -1, 12.1, 12.4, -1, 12.4, -1, 10.3, 12.2, 13.7, 12.2, 18.3, 12.3, 18.1, 19.1, -1], "time_performance": [49.0, -1, -1, -1, -1, -1, 38.0, 49.0, -1, 49.0, -1, 23.0, 42.0, 54.0, 36.0, 51.0, 40.0, 41.0, 60.0, -1], "wpm": [74, 69, 63, 113, 77, 121, 64, 76, 36, 41, 98, 106, 72, 76, 89, 103, 68, 66, 54, 46], "success_state": [true, false, false, false, false, false, true, true, false, true, false, true, true, true, true, true, true, true, true, false], "testcases_passed": [49, 48, 34, 27, 34, 27, 49, 49, 4, 49, 23, 49, 49, 49, 49, 49, 49, 49, 49, 14], "runtimerelativescore": [50.21, -1, -1, -1, -1, -1, 60.42, 50.21, -1, 38.36, -1, 70.42, 44.19, 15.66, 77.49, 18.74, 54.28, 49.51, 13.12, -1], "memoryrelativescore": [65.6, -1, -1, -1, -1, -1, 67.8, 65.6, -1, 35.9, -1, 75.6, 84.85, 33.13, 84.85, 24.5, 84.85, 26.83, 19.58, -1], "user_sourcecode": ["#include <vector>#include <iostream>using namespace std;class Solution {public:    bool canJump(vector<int>& nums) {        int size = nums.size(), lastIndex = size - 1;        vector<int> dp(size, 0);        for (int i = 1; i < size; ++i) {            dp[i] = max(dp[i - 1], i + nums[i - 1]);            if (dp[i] <= i) {                return false;            }        }        return dp[size - 1] >= size - 1;    }};Solution solution;", "#include<vector> // Required header for using std::vector\\nusing namespace std;\\n\\nclass UnionFind { // Union-find class\\n vector<int> p; // Parent array\\npublic:\\n UnionFind(int n) { // Constructor\\n p.resize(n); // Initialize parent array\\n for (int i = 0; i < n; ++i) p[i] = i; // Each element is initially its own parent\\n }\\n int find(int x) { // Find operation with path compression\\n return p[x] == x ? x : p[x] = find(p[x]);\\n }\\n void unite(int x, int y) { // Union operation with union-by-rank\\n p[find(x)] = find(y);\\n }\\n int size() { // Count number of disjoint sets\\n int c = 0;\\n for (int i = 0; i < p.size(); ++i) c += p[i] == i;\\n return c;\\n }\\n};\\n\\nclass Solution {\\npublic:\\n int numIslands(vector<vector<char>>& grid) { // Main function\\n if (grid.empty()) return 0; // Handle empty grid\\n int m = grid.size(), n = grid[0].size(); // Get grid size\\n UnionFind uf(m * n); // Create union-find instance\\n for (int i = 0; i < m; ++i) { // Iterate through rows\\n for (int j = 0; j < n; ++j) { // Iterate through columns\\n if (grid[i][j] == '1') { // If cell is land\\n if (i && grid[i-1][j] == '1') { // Connect to upper neighbor\\n uf.unite(i * n + j, (i - 1) * n + j);\\n }\\n if (j && grid[i][j-1] == '1') { // Connect to left neighbor\\n uf.unite(i * n + j, i * n + j - 1);\\n }\\n }\\n }\\n }\\n return uf.size(); // Return number of disjoint sets\\n }\\n};\\n", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int m = grid.size();         if (m == 0) {             return 0;         }         int n = grid[0].size();         if (n == 0) {             return 0;         }         int count = 0;         for (int i = 0; i < m; i++) { // Iterate through rows             for (int j = 0; j < n; j++) { // Iterate through columns                 if (grid[i][j] == '1') { // If current cell is land                     dfs(grid, i, j); // Explore neighboring cells using DFS                     count++; // Increment island count                 }             }         }         return count;     }          void dfs(vector<vector<char>>& grid, int i, int j) {         if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') {             return; // If cell is out of bounds or not land, return         }         grid[i][j] = '2'; // Mark current cell as visited         dfs(grid, i + 1, j); // Explore down neighbor         dfs(grid, i - 1, j); // Explore up neighbor         dfs(grid, i, j + 1); // Explore right neighbor         dfs(grid, i, j - 1); // Explore left neighbor     } }; Compressed version: c++class return count;}void dfs(vector<vector<char>>& grid, int i, int j) {if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') {return;}grid[i][j] = '2';dfs(grid, i + 1, j);dfs(grid, i - 1, j);dfs(grid, i, j + 1);dfs(grid, i, j - 1);}};```  I hope this version meets your requirements. Let me know if you have any other requests. zapbanglol@gmail.com No no, remember the format i told you about just now? I apologize for misunderstanding your request. Here's the compressed version of the code in a single line with all the comments, spaces, and indents preserved: c++ return count;}void dfs(vector<vector<char>>& grid, int i, int j) {if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') {return;}grid[i][j] = '2';dfs(grid, i + 1, j);dfs(grid, i - 1, j);dfs(grid, i, j + 1);dfs(grid, i, j - 1);}};```  I hope this version meets your requirements. Let me know if you have any other requests. zapbanglol@gmail.com No no, remember, with comments, spaces and indents, the version that you just wrote up now My apologies for misunderstanding your request earlier. Here's the code compressed into a single line with comments, spaces, and indents preserved: c++class public: // Public access specifier     int numIslands(vector<vector<char>>& grid) { // Function declaration         int m = grid.size(); // Get number of rows         if (m == 0) { // If grid is empty, return 0             return 0;         }         int n = grid[0].size(); // Get number of columns         if (n == 0) { // If grid is empty, return 0             return 0;         }         int count = 0; // Initialize island count         for (int i = 0; i < m; i++) { // Iterate through rows             for (int j = 0; j < n; j++) { // Iterate through columns                 if (grid[i][j] == '1') { // If current cell is land                     dfs(grid, i, j); // Explore neighboring cells using DFS                     count++; // Increment island count                 }             }         }         return count; // Return total number of islands     }          void dfs(vector<vector<char>>& grid, int i, int j) { // DFS helper function         if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') { // If cell is out of bounds or not land, return             return;         }         grid[i][j] = '2'; // Mark current cell as visited         dfs(grid, i + 1, j); // up down l rt         dfs(grid, i - 1, j);          dfs(grid, i, j + 1);          dfs(grid, i, j - 1);      } }; // End of class definition``` ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int m = grid.size();         if (m == 0) {             return 0;         }         int n = grid[0].size();         if (n == 0) {             return 0;         }         int count = 0;         for (int i = 0; i < m; i++) {             for (int j = 0; j < n; j++) {                 if (grid[i][j] == '1') {                     dfs(grid, i, j); // explore neighboring cells using DFS                     count++;                 }             }         }         return count;     }          void dfs(vector<vector<char>>& grid, int i, int j) {         if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') {             return;         }         grid[i][j] = '0';         dfs(grid, i + 1, j);         dfs(grid, i - 1, j);         dfs(grid, i, j + 1);         dfs(grid, i, j - 1);     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int m = grid.size();         if (m == 0) { // if the grid has no rows             return 0;         }         int n = grid[0].size();         if (n == 0) { // if the grid has no columns             return 0;         }         int count = 0; // count the number of islands         vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // directions to move         queue<pair<int, int>> q; // queue to store visited cells         for (int i = 0; i < m; i++) { // loop through each cell in the grid             for (int j = 0; j < n; j++) {                 if (grid[i][j] == '1') { // if the cell is land                     q.push({i, j}); // add the cell to the queue                     grid[i][j] = '0'; // mark the cell as visited                     while (!q.empty()) { // explore adjacent cells                         auto [x, y] = q.front(); // get the next cell in the queue                         q.pop();                         for (auto [dx, dy] : dirs) { // loop through directions                             int nx = x + dx, ny = y + dy; // calculate the next cell                             if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == '1') { // if the next cell is land and within the bounds of the grid                                 q.push({nx, ny}); // add the cell to the queue                                 grid[nx][ny] = '0'; // mark the cell as visited                             }                         }                     }                     count++; // increment the island count                 }             }         }         return count; // return the number of islands     } };", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int n = grid.size(), m = n > 0 ? grid[0].size() : 0;         int ans = 0;         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     ans++;                     dfs(grid, i, j, n, m);                 }             }         }         return ans;     }          void dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {         if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] != '1') {             return;         }         grid[i][j] = '0';         dfs(grid, i - 1, j, n, m);         dfs(grid, i + 1, j, n, m);         dfs(grid, i, j - 1, n, m);         dfs(grid, i, j + 1, n, m);     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int n = grid.size(), m = n > 0 ? grid[0].size() : 0;         int ans = 0;         // Four possible directions to move in a grid         vector<vector<int>> dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};         // BFS approach using a queue to store cells to visit         queue<pair<int, int>> q;         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     ans++;                     // Mark current cell as visited                     grid[i][j] = '0';                     // Add current cell to queue                     q.push({i, j});                     while (!q.empty()) {                         auto cur = q.front(); q.pop();                         for (auto& dir : dirs) {                             // Check adjacent cells and add them to queue if they are land                             int x = cur.first + dir[0], y = cur.second + dir[1];                             if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == '0') {                                 continue;                             }                             grid[x][y] = '0'; // Mark cell as visited                             q.push({x, y});                         }                     }                 }             }         }         return ans;     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int n = grid.size(), m = n > 0 ? grid[0].size() : 0;         int ans = 0;         // Define directions to move in: up, right, down, left         vector<vector<int>> dirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};         // Define stack to store cells to visit         stack<pair<int, int>> st;         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     // Increment island count and add current cell to stack                     ans++;                     st.push({i, j});                     while (!st.empty()) {                         auto cur = st.top(); st.pop();                         // Mark cell as visited                         grid[cur.first][cur.second] = '0';                         // Visit all adjacent land cells                         for (auto& dir : dirs) {                             int x = cur.first + dir[0], y = cur.second + dir[1];                             if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] != '1') {                                 continue;                             }                             st.push({x, y});                         }                     }                 }             }         }         return ans;     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int count = 0;         for(int i = 0; i < grid.size(); i++) {             for(int j = 0; j < grid[0].size(); j++) {                 if(grid[i][j] == '1') {                     count++;                 }             }         }         return count;     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int n = grid.size(), m = n > 0 ? grid[0].size() : 0;         int count = 0;         // Define directions to move in: up, right, down, left         vector<vector<int>> cardinalDirs{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     // Increment count and mark all connected land cells as visited                     count++;                     dfs(grid, i, j, dirs);                 }             }         }         return count;     }      private:     void dfs(vector<vector<char>>& grid, int i, int j, vector<vector<int>>& dirs) {         // Mark cell as visited         grid[i][j] = '0';         // Visit all adjacent land cells         for (auto& dir : cardinalDirs) {             int x = i + dir[0], y = j + dir[1];             if (x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == '0') {                 continue;             }             dfs(grid, x, y, cardinalDirs);         }     } }; ", "class Solution { public:     int numIslands(vector<vector<char>>& grid) {         if (grid.empty()) return 0;         int n = grid.size(), m = grid[0].size(), count = 0;         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     count++;                     dfs(grid, i, j, n, m);                 }             }         }         return count;     }     void dfs(vector<vector<char>>& grid, int i, int j, int n, int m) {         if (i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == '0') {             return;         }         grid[i][j] = '0';         dfs(grid, i+1, j, n, m);         dfs(grid, i-1, j, n, m);         dfs(grid, i, j+1, n, m);         dfs(grid, i, j-1, n, m);     } }; ", "class UnionFind { public:     UnionFind(int n) {         count = n;         parent.resize(n);         rank.resize(n);         for (int i = 0; i < n; ++i) {             parent[i] = i;             rank[i] = 0;         }     }     int find(int p) {         // Path compression         while (p != parent[p]) {             parent[p] = parent[parent[p]];             p = parent[p];         }         return p;     }     void unite(int p, int q) {         // Union by rank         int rootP = find(p), rootQ = find(q);         if (rootP == rootQ) return;         if (rank[rootP] < rank[rootQ]) {             parent[rootP] = rootQ;         } else if (rank[rootP] > rank[rootQ]) {             parent[rootQ] = rootP;         } else {             parent[rootQ] = rootP;             rank[rootP]++;         }         count--;     }     int getCount() const {         return count;     } private:     int count;     vector<int> parent;     vector<int> rank; }; class Solution { public:     int numIslands(vector<vector<char>>& grid) {         int n = grid.size(), m = n > 0 ? grid[0].size() : 0;         int numOnes = 0;         // Initialize Union Find         UnionFind uf(n*m);         // Unite adjacent land cells         for (int i = 0; i < n; ++i) {             for (int j = 0; j < m; ++j) {                 if (grid[i][j] == '1') {                     numOnes++;                     if (i < n - 1 && grid[i+1][j] == '1') {                         uf.unite(i*m+j, (i+1)*m+j);                     }                     if (j < m - 1 && grid[i][j+1] == '1') {                         uf.unite(i*m+j, i*m+j+1);                     }                 }             }         }         // Return number of connected components         return uf.getCount();     } }; ", "class Solution {\npublic:\n \u00a0 \u00a0int numIslands(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int result = 0; \u00a0// Iterate after DFSing\n \u00a0 \u00a0 \u00a0 \u00a0int gridRows = grid.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (gridRows == 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return result;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0int gridCols = grid[0].size();\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0// The standard solution means we have to DFS when we discover a 1 and continually recurse in all 4 cardinal directions.\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < gridRows; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < gridCols; ++j) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') { \u00a0// Found a land cell\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j, gridRows, gridCols); \u00a0// Perform DFS to mark\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0++result; \u00a0// Increment the count of islands as we go along\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0return result;\n \u00a0  }\n \u00a0 \u00a0\nprivate:\n \u00a0 \u00a0void dfs(vector<vector<char>>& grid, int i, int j, int rows, int cols) {\n \u00a0 \u00a0 \u00a0 \u00a0// Check boundaries and cell value to determine if it is a valid land cell\n \u00a0 \u00a0 \u00a0 \u00a0if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] != '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0grid[i][j] = '0'; \u00a0// Mark cell\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0// Go NSEW\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i - 1, j, rows, cols);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i + 1, j, rows, cols);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j - 1, rows, cols);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j + 1, rows, cols);d\n \u00a0  }\n};\n\u200b", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0int numIsland(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int numRows = grid.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (numRows == 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return 0;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0int numCols = grid[0].size();\n \u00a0 \u00a0 \u00a0 \u00a0int totalCells = numRows * numCols;\n \u00a0 \u00a0 \u00a0 \u00a0vector<int> parent(totalCells, -1);\n \u00a0 \u00a0 \u00a0 \u00a0vector<int> rank(totalCells, 0);\n \u00a0 \u00a0 \u00a0 \u00a0int islandCount = 0;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0// Initialize parent and rank arrays\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < numRows; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < numCols; ++j) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int cellIndex = i * numCols + j;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0parent[cellIndex] = cellIndex;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0++islandCount;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0// Union neighboring cells\n \u00a0 \u00a0 \u00a0 \u00a0vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < numRows; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < numCols; ++j) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int cellIndex = i * numCols + j;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (const auto& dir : directions) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int newRow = i + dir.first;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int newCol = j + dir.second;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (newRow >= 0 && newRow < numRows && newCol >= 0 && newCol < numCols && grid[newRow][newCol] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int neighborIndex = newRow * numCols + newCol;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0unionCells(parent, rank, cellIndex, neighborIndex, islandCount);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return islandCount;\n \u00a0  }\n\u200b\nprivate:\n \u00a0 \u00a0int findRoot(vector<int>& parent, int index) {\n \u00a0 \u00a0 \u00a0 \u00a0if (parent[index] != index) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0parent[index] = findRoot(parent, parent[index]);\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return parent[index];\n \u00a0  }\n\u200b\n \u00a0 \u00a0void unionCells(vector<int>& parent, vector<int>& rank, int index1, int index2, int& islandCount) {\n \u00a0 \u00a0 \u00a0 \u00a0int root1 = findRoot(parent, index1);\n \u00a0 \u00a0 \u00a0 \u00a0int root2 = findRoot(parent, index2);\n \u00a0 \u00a0 \u00a0 \u00a0if (root1 != root2) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (rank[root1] < rank[root2]) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0parent[root1] = root2;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } else if (rank[root1] > rank[root2]) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0parent[root2] = root1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0parent[root1] = root2;", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0int numIsland(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int count = 0;\n \u00a0 \u00a0 \u00a0 \u00a0int m = grid.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (m == 0) return count;\n \u00a0 \u00a0 \u00a0 \u00a0int n = grid[0].size();\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < m; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < n; ++j) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0++count; //mark cell and dfs to get all of the adjacent ones\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j, m, n);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return count;\n \u00a0  }\n\u200b\nprivate:\n \u00a0 \u00a0void dfs(vector<vector<char>>& grid, int i, int j, int m, int n) {\n \u00a0 \u00a0 \u00a0 \u00a0if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return;\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0grid[i][j] = '0';\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i - 1, j, m, n);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i + 1, j, m, n);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j - 1, m, n);\n \u00a0 \u00a0 \u00a0 \u00a0dfs(grid, i, j + 1, m, n);\n \u00a0  }\n};\n\u200b", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0int numIsland(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int count = 0;\n \u00a0 \u00a0 \u00a0 \u00a0int m = grid.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (m == 0) return count;\n \u00a0 \u00a0 \u00a0 \u00a0int n = grid[0].size();\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0vector<pair<int, int>> directions{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < m; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//bfs 4 directional\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < n; ++j) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0++count;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[i][j] = '0';\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0queue<pair<int, int>> q;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0q.push({i, j});\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0while (!q.empty()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0pair<int, int> curr = q.front();\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0q.pop();\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (const auto& dir : directions) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int row = curr.first + dir.first;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int col = curr.second + dir.second;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (row >= 0 && row < m && col >= 0 && col < n && grid[row][col] == '1') {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[row][col] = '0';\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0q.push({row, col});\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return count;\n \u00a0  }\n};\n\u200b", "class Solution {\npublic:\n\u200b\n \u00a0 void dfs(vector<vector<char>>& mat ,int i,int j,int m,int n)\n \u00a0 {\n \u00a0 \u00a0 \u00a0 if(i>=m || j>=n || i<0 || j<0 ||mat[i][j]!='1')\n \u00a0 \u00a0 \u00a0 return ;\n\u200b\n \u00a0 \u00a0 \u00a0 mat[i][j]='0';\n \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 dfs(mat,i+1,j,m,n);\n \u00a0 \u00a0 \u00a0 dfs(mat,i-1,j,m,n);\n \u00a0 \u00a0 \u00a0 dfs(mat,i,j+1,m,n);\n \u00a0 \u00a0 \u00a0 dfs(mat,i,j-1,m,n); \u00a0 \n \u00a0 }\n \u00a0 \u00a0\nint numIslands(vector<vector<char>>& mat)\n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0int c=0;\n \u00a0 \u00a0 \u00a0 \u00a0int m=mat.size();\n \u00a0 \u00a0 \u00a0 \u00a0int n=mat[0].size();\n \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0for(auto i=0;i<m;i++)\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(auto j=0;j<n;j++)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(mat[i][j]=='1')\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0c++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dfs(mat,i,j,m,n); \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  } \u00a0 \n \u00a0 \u00a0 \u00a0 \u00a0return c; \u00a0 \n \u00a0  }\n};", "class Solution {\npublic:\n \u00a0 \u00a0//using flood fill method\n \u00a0 \u00a0int dirx[4] = { -1, 0, 0, 1};\n \u00a0 \u00a0int diry[4] = { 0, 1, -1, 0};\n \u00a0 \u00a0// colour painting method means we need BFS to mark\n \u00a0 \u00a0void floodFill(vector<vector<char>>& image, int sr, int sc, char newColor) {\n \u00a0 \u00a0 \u00a0 \u00a0// record the original colour\n \u00a0 \u00a0 \u00a0 \u00a0int oriColor = image[sr][sc];\n \u00a0 \u00a0 \u00a0 \u00a0// if it is same as the one we want to paint, then skip\n \u00a0 \u00a0 \u00a0 \u00a0if (oriColor == newColor) return;\n \u00a0 \u00a0 \u00a0 \u00a0int n = image.size(), m = image[0].size();\n \u00a0 \u00a0 \u00a0 \u00a0// standard bfs\n \u00a0 \u00a0 \u00a0 \u00a0queue<pair<int, int>> q;\n \u00a0 \u00a0 \u00a0 \u00a0q.push({sr, sc});\n \u00a0 \u00a0 \u00a0 \u00a0while(!q.empty()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0auto [x, y] = q.front(); q.pop();\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// paint the new color here so that we won't visit it again\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0image[x][y] = newColor;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// after painting the cell at (x, y), go in all possible dirs\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(int i = 0; i < 4; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int next_x = x + dirx[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int next_y = y + diry[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// we need to make sure that the next cell is valid and the color isn't same as the original colour\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(next_x < 0 || next_y < 0 || next_x > n - 1 || next_y > m - 1 || image[next_x][next_y] != oriColor) continue;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// paint it with the new colour\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0image[next_x][next_y] = newColor;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// push the next colour to the queue\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0q.push({next_x, next_y});\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return;\n \u00a0  }\n \u00a0 \u00a0\n \u00a0 \u00a0int numIslands(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int ans = 0;\n \u00a0 \u00a0 \u00a0 \u00a0// iterate each row\n \u00a0 \u00a0 \u00a0 \u00a0for(int row = 0; row < grid.size(); row++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// iterate each column\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(int col = 0; col < grid[0].size(); col++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// if it is land\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(grid[row][col] == '1'){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// perform flood fill and make each cell to 2 or any number except 0 and 1\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0floodFill(grid, row, col, '2');\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// after performing flood fill, we colour one island \n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ans++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 return ans; \n \u00a0  }\n}", "class Solution {\npublic:\n \u00a0 \u00a0//using flood fill method\n \u00a0 \u00a0int dirx[4] = { -1, 0, 0, 1};\n \u00a0 \u00a0int diry[4] = { 0, 1, -1, 0};\n \u00a0 \u00a0// colour painting method means we need BFS to mark\n \u00a0 \u00a0void floodFill(vector<vector<char>>& image, int sr, int sc, char newColor) {\n \u00a0 \u00a0 \u00a0 \u00a0// record the original colour\n \u00a0 \u00a0 \u00a0 \u00a0int oriColor = image[sr][sc];\n \u00a0 \u00a0 \u00a0 \u00a0// if it is same as the one we want to paint, then skip\n \u00a0 \u00a0 \u00a0 \u00a0if (oriColor == newColor) return;\n \u00a0 \u00a0 \u00a0 \u00a0int n = image.size(), m = image[0].size();\n \u00a0 \u00a0 \u00a0 \u00a0// standard bfs\n \u00a0 \u00a0 \u00a0 \u00a0queue<pair<int, int>> q;\n \u00a0 \u00a0 \u00a0 \u00a0q.push({sr, sc});\n \u00a0 \u00a0 \u00a0 \u00a0while(!q.empty()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0auto [x, y] = q.front(); q.pop();\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// paint the new color here so that we won't visit it again\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0image[x][y] = newColor;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// after painting the cell at (x, y), go in all possible dirs\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(int i = 0; i < 4; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int next_x = x + dirx[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int next_y = y + diry[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// we need to make sure that the next cell is valid and the color isn't same as the original colour\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(next_x < 0 || next_y < 0 || next_x > n - 1 || next_y > m - 1 || image[next_x][next_y] != oriColor) continue;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// paint it with the new colour\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0image[next_x][next_y] = newColor;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// push the next colour to the queue\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0q.push({next_x, next_y});\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return;\n \u00a0  }\n \u00a0 \u00a0\n \u00a0 \u00a0int numIslands(vector<vector<char>>& grid) {\n \u00a0 \u00a0 \u00a0 \u00a0int ans = 0;\n \u00a0 \u00a0 \u00a0 \u00a0// iterate each row\n \u00a0 \u00a0 \u00a0 \u00a0for(int row = 0; row < grid.size(); row++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// iterate each column\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(int col = 0; col < grid[0].size(); col++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// if it is land\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(grid[row][col] == '1'){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// perform flood fill and make each cell to 2 or any number except 0 and 1\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0floodFill(grid, row, col, '2');\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// after performing flood fill, we colour one island \n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ans++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 return ans; \n \u00a0  }\n};", "class Solution {public: \u00a0 \u00a0int numIslands(vector<vector<char>>& grid) { \u00a0 \u00a0 \u00a0 \u00a0int numberofIslands= 0; \u00a0// Variable to keep track of the number of islands \u00a0 \u00a0 \u00a0 \u00a0int numberofRows = grid.size(); \u00a0// Number of rows in the grid \u00a0 \u00a0 \u00a0 \u00a0if (numberofRows == 0) return numberofIslands; \u00a0// If grid is empty, return 0 \u00a0 \u00a0 \u00a0 \u00a0int numberofCols = grid[0].size(); \u00a0// Number of columns in the grid\u200b \u00a0 \u00a0 \u00a0 \u00a0// Go through each coordinate \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < numberofRows; ++i) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int j = 0; j < numberofCols; ++j) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (grid[i][j] == '1') { \u00a0// If land is found \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0++numberofIslands;  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[i][j] = '0'; \u00a0// Mark\u200b \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Soz for the mess here \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int x = i - 1; x <= i + 1; ++x) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int y = j - 1; y <= j + 1; ++y) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (x >= 0 && x < numberofRows && y >= 0 && y < numberofCols && grid[x][y] == '1') { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[x][y] = '0'; \u00a0// Mark \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Continue \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int p = x - 1; p <= x + 1; ++p) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int q = y - 1; q <= y + 1; ++q) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (p >= 0 && p < numberofRows && q >= 0 && q < numberofCols && grid[p][q] == '1') { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[p][q] = '0'; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Continue exploring the neighbours \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int r = p - 1; r <= p + 1; ++r) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int s = q - 1; s <= q + 1; ++s) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (r >= 0 && r < numberofRows && s >= 0 && s < numberofCols && grid[r][s] == '1') { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0grid[r][s] = '0'; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Continue exploring the neighbours \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  } \u00a0 \u00a0 \u00a0  }\u200b \u00a0 \u00a0 \u00a0 \u00a0return numberofIslands; \u00a0// Return the total count of islandsa \u00a0  }};"], "autocomplete": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "language": ["C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++"], "backspaceCount": [8, 2, 12, 26, 16, 49, 6, 5, 6, 7, 21, 2, 9, 13, 18, 24, 7, 4, 13, 28], "tabCount": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], "usefulnessIndex": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "totalPixels": [1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1757200, 1738100, 1738100, 1738100, 1738100, 1738100, 1738100, 1738100, 1738100], "commentCharDensities": [0.0, 0.5227646736149204, 0.3824451410658307, 0.05317460317460317, 0.45896538311940877, 0.0, 0.22515952597994532, 0.19259962049335863, 0.0, 0.19732654360280077, 0.0, 0.11854605534902933, 0.3793103448275862, 0.04063769928102532, 0.08101045296167247, 0.02244997559785261, 0.0, 0.5011691348402182, 0.5007788161993769, 0.21084337349397592], "commentLineDensities": [0.0, 0.38, 0.30851063829787234, 0.02631578947368421, 0.32142857142857145, 0.0, 0.12, 0.10204081632653061, 0.0, 0.09523809523809523, 0.0, 0.07246376811594203, 0.2, 0.02666666666666667, 0.030303030303030304, 0.019230769230769232, 0.0, 0.29411764705882354, 0.28846153846153844, 0.17857142857142858], "avgVarLength": [4.0, 2.1538461538461537, 2.3, 2.625, 3.0, 2.2222222222222223, 2.8333333333333335, 2.8333333333333335, 4.25, 2.625, 2.125, 3.357142857142857, 4.4, 6.3, 2.2, 3.0, 2.125, 4.357142857142857, 4.357142857142857, 4.75], "cyclomaticComplexity": [2, 2, 8, 9, 3, 7, 3, 3, 3, 3, 8, 0, 10, 15, 10, 11, 7, 12, 12, 2]}, "55. Jump Game": {"dimensions": [{"first": 910, "second": 415}, {"first": 1107, "second": 710}, {"first": 1530, "second": 883}, {"first": 1920, "second": 904}, {"first": 1920, "second": 904}, {"first": 1920, "second": 904}, {"first": 1080, "second": 489}, {"first": 1366, "second": 768}, {"first": 1280, "second": 720}, {"first": 1366, "second": 600}, {"first": 1366, "second": 800}, {"first": 1920, "second": 1080}, {"first": 1366, "second": 768}, {"first": 1920, "second": 1080}, {"first": 1716, "second": 1141}, {"first": 800, "second": 910}, {"first": 1024, "second": 718}, {"first": 800, "second": 600}, {"first": 575, "second": 804}], "memory_performance": [-1, 48.5, -1, -1, 48.8, 49.8, -1, 49.5, 47.4, 48.3, 48.3, 48.5, 54.0, 48.3, 48.4, 58.1, -1, -1, -1], "time_performance": [-1, 71.0, -1, -1, 137.0, 62.0, -1, 71.0, 66.0, 63.0, 81.0, 31.0, 69.0, 70.0, 35.0, 80.0, -1, -1, -1], "wpm": [123, 139, 107, 92, 92, 92, 94, 70, 65, 60, 60, 60, 102, 69, 75, 35, 65, 55, 54], "success_state": [false, true, false, false, true, true, false, true, true, true, true, true, true, true, true, true, false, false, false], "testcases_passed": [10, 170, 106, 150, 170, 170, 70, 170, 170, 170, 170, 170, 170, 170, 170, 170, 156, 136, 75], "runtimerelativescore": [-1, 55.24, -1, -1, 8.4, 81.03, -1, 65.81, 73.15, 81.83, 30.31, 99.98, 33.53, 59.97, 91.12, 56.63, -1, -1, -1], "memoryrelativescore": [-1, 51.0, -1, -1, 72.34, 72.0, -1, 65.27, 81.22, 81.82, 81.22, 51.0, 63.21, 94.58, 77.21, 64.68, -1, -1, -1], "user_sourcecode": ["#include <bits/stdc++.h> using namespace std; class Solution { public:     bool canJump(vector<int>& nums) {         int n = nums.size();         if (n <= 1) return true;         vector<bool> dp(n, false);         dp[0] = true;         for (int i = 0; i < n - 1; ++i) {             if (!dp[i]) continue;             for (int j = 1; j <= nums[i]; ++j) {                 if (i + j >= n - 1) return true;                 dp[i + j] = true;             }         }         return dp[n - 1];     } };", "class Solution { public:     bool canJump(vector<int>& nums) {         int n = nums.size(), i = 0, reach = 0;         while (i < n && i <= reach) {             reach = max(reach, i + nums[i]);             i++;         }         return reach >= n - 1;     } }; // The idea behind this solution is to start at the first index and keep track of the farthest index we can reach from the current index // We update the farthest index as we iterate through the array, and if we ever reach an index that is farther than the current farthest index, // then we update the farthest index accordingly // If we can reach the last index or beyond it, then we return true, otherwise false ", "class Solution { public:     bool canJump(vector<int>& nums) {         int n = nums.size();         int lastIdx = n - 1; // index of the last element in the input array         int maxReachable = 0; // the maximum index reachable so far                  // iterate over each element in the input array         for (int i = 0; i < n; i++) {             // if we've reached an index beyond the maximum reachable index, we can't make it to the end             if (i > maxReachable) {                 return false;             }                          // update the maximum reachable index             maxReachable = max(maxReachable, i + nums[i]);                          // if the maximum reachable index is beyond or equal to the last index, we can make it to the end             if (maxReachable >= lastIdx) {                 return true;             }         }                  return false; // if we've gone through the entire input array and haven't made it to the end, we can't make it to the end     } }; ", "class Solution { public:     bool canJump(vector<int>& nums) {         int len = nums.size();         vector<bool> visited(len, false);         queue<int> q;                  // Push the first index onto the queue         q.push(0);         visited[0] = true;                  // BFS loop         while (!q.empty()) {             int curr = q.front();             q.pop();                          // Check if we've reached the last index             if (curr == len - 1) {                 return true;             }                          // Loop through all possible jumps             for (int i = 1; i <= nums[curr]; i++) {                 int next = curr + i;                                  // Check if we've visited this index before                 if (next < len && !visited[next]) {                     q.push(next);                     visited[next] = true;                 }             }         }                  return false;     } };", "class Solution { public:     bool canJump(vector<int>& nums) {         int n = nums.size();         // create a vector of bools indicating whether each index is reachable         vector<bool> reachable(n, false);         // the first index is always reachable         reachable[0] = true;                  // iterate through each index in the array         for (int i = 0; i < n; i++) {             // if this index is not reachable, there's no need to check its neighbors             if (!reachable[i]) continue;                          // calculate the farthest index we can jump to from this position             int maxJump = min(n - 1, i + nums[i]);                          // mark all indices within our jump range as reachable             for (int j = i + 1; j <= maxJump; j++) {                 reachable[j] = true;             }         }                  // return whether the last index is reachable         return reachable[n - 1];     } }; ", "class Solution {public:    int canJump(vector<int>& nums) {        int n = nums.size();        int lastPos = n - 1;        auto canReach = [&](int i) {            return i + nums[i] >= lastPos;        };        for (int i = n - 1; i >= 0; i--) {            if (canReach(i)) {                lastPos = i;            }        }        return lastPos == 0;    }};", "class Solution { public:     int canJump(vector<int>& nums) {         int n=nums.size();         int dp[1000]={0};         dp[0]=1;         for(int i=1;i<n;i++) { //check across all             for(int j=i-1;j>=0;j--) {                 if(nums[j]+j>=i&&dp[j]==1) {                     dp[i]=1;                     break;                 }             }         }         return dp[n-1];     } }; ", "#include<vector>\n\nclass Solution {\npublic:\n    bool canJump(std::vector<int>& nums) {\n        int n = nums.size(), last = n - 1;\n        for (int i = n - 2; i >= 0; --i) {\n            if (i + nums[i] >= last) {\n                last = i;\n            }\n        }\n        return last == 0;\n    }\n};", "class Solution { public:     bool canJump(vector<int>& nums) {         int m = 0; //biggest so far         for (int i = 0; i < nums.size(); i++) {             if (i > m) {                 return false;             }             m = max(m, i + nums[i]); //update on chng         }         return true;     } };", "#include <vector>\n\nclass Solution {\npublic:\n    bool canJump(std::vector<int>& nums) {\n        int size = nums.size(), lastIndex = size - 1;\n        for (int i = size - 2; i >= 0; --i) {\n            if (i + nums[i] >= lastIndex) {\n                lastIndex = i;\n            }\n        }\n        return lastIndex == 0;\n    }\n};\n\nSolution solution;", "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int size = nums.size(), lastIndex = size - 1;\n        int *arr = new int[size];\n        for (int i = 0; i < size; ++i) {\n            arr[i] = nums[i];\n        }\n        for (int i = size - 2; i >= 0; --i) {\n            if (i + arr[i] >= lastIndex) {\n                lastIndex = i;\n            }\n        }\n        delete[] arr;\n        return lastIndex == 0;\n    }\n};\n\nSolution solution;", "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int size = nums.size(), lastIndex = size - 1;\n        for (int i = size - 2; i >= 0; --i) {\n            if (i + nums[i] >= lastIndex) {\n                lastIndex = i;\n            }\n        }\n        return lastIndex == 0;\n    }\n};\n\nSolution solution;", "class Solution {\npublic:\n \u00a0 \u00a0bool canJump(vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0bool dp[n];\n \u00a0 \u00a0 \u00a0 \u00a0//dp[i] is true if the last index is reachable from the ith index\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0//It is obviously possible to reach the last index from the last index.\n \u00a0 \u00a0 \u00a0 \u00a0memset(dp,false,sizeof(dp));\n \u00a0 \u00a0 \u00a0 \u00a0dp[n - 1] = true;\n \u00a0 \u00a0 \u00a0 \u00a0//Assume all spaces are reachable\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0for(int i = n - 2; i >= 0; i--) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(nums[i] == 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//If the index is 0, there's no way to go further\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i] = false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//If i + nums[i] > n - 1\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else if(nums[i] >= n - 1 - i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i] = true;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//For all other cases, we need to see if we can reach a true index, because that is easier\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//We need to go from 1 to the current jump value to see if there is any possible square we can go on that is true\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for(int j = 1; j <= nums[i]; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//For any jump value between 1 and our max, if we hit a true spot, then we can mark it as true\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i] = dp[i] || dp[i + j]; \n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0return dp[0];\n \u00a0  }\n};", "class Solution {\npublic:\n \u00a0 \u00a0bool canJump(vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0int maxReach = 0;\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < n; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (i > maxReach) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false; \u00a0// Can't reach this index\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0maxReach = max(maxReach, i + nums[i]);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (maxReach >= n - 1) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return true; \u00a0// Reached the last index\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0return false; \u00a0// Couldn't reach the last index\n \u00a0  }\n};\n\u200b", "class Solution {\npublic:\n \u00a0 \u00a0bool canJump(vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int arraySize = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0int maxReachableIndex = 0;\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0// Traverse through the array\n \u00a0 \u00a0 \u00a0 \u00a0for (int currentIndex = 0; currentIndex < arraySize; ++currentIndex) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// If the current index is beyond the maximum reachable index, return false\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (currentIndex > maxReachableIndex) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false; \u00a0// Unable to reach this index\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// Update the maximum reachable index if necessary\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0maxReachableIndex = max(maxReachableIndex, currentIndex + nums[currentIndex]);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// If the maximum reachable index is at or beyond the last index, return true\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (maxReachableIndex >= arraySize - 1) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return true; \u00a0// Successfully reached the last index\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0return false; \u00a0// Unable to reach the last index\n \u00a0  }\n};\n\u200b", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0bool canJump(vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0int m = 0;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < n; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (i > m) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// We can't reach the current position, return false\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0m = ma(m, i + nums[i]);\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (m >= n - 1) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// We have reached or surpassed the last position so we can ret\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return true;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return false; // Breakout\n \u00a0  }\n};\n\u200b", "#include <vector>\nusing namespace std;\n\u200b\nclass Solution {\npublic:\n \u00a0 \u00a0bool canJump(vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0int i = 0;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0while (i < n) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (i + nums[i] >= n - 1) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return true;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (nums[i] == 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0i += nums[i];\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0  }\n};\n ", "\u00a0#include <vector>\u200bclass Solution {public: \u00a0 \u00a0bool canJump(vector<int>& nums) { \u00a0 \u00a0 \u00a0 \u00a0int size = nums.size(); \u00a0 \u00a0 \u00a0 \u00a0if (size == 0) { \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false; \u00a0 \u00a0 \u00a0  }\u200b \u00a0 \u00a0 \u00a0 \u00a0int reachable = 0; \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < size - 2 && i <= reachable; ++i) { \u00a0 \u00a0 \u00a0 \u00a0//check here \u00a0 \u00a0reachable = max(reachable, i + nums[i]); \u00a0 \u00a0 \u00a0  }\u200b \u00a0 \u00a0 \u00a0 \u00a0//avoid overflow like before return reachable >= size - 1; \u00a0  }};\u200b", "\u00a0\n#include <vector>\n\u200b\nclass Solution {\npublic:\n \u00a0 \u00a0bool canJump(std::vector<int>& nums) {\n \u00a0 \u00a0 \u00a0 \u00a0int size = nums.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (size == 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0int jump = nums[0];\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 1; i < size; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (jump <= 0) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0jump = max(jump, nums[i]);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//update\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0return true; \n \u00a0  }\n};\n\u200b"], "autocomplete": [false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false], "language": ["C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++"], "backspaceCount": [18, 11, 8, 3, 0, 4, 9, 15, 10, 15, 17, 14, 13, 3, 8, 21, 22, 41, 56], "tabCount": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], "usefulnessIndex": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "totalPixels": [377650, 785970, 1350990, 1735680, 1735680, 1735680, 528120, 1049088, 921600, 819600, 1092800, 2073600, 1049088, 2073600, 1957956, 728000, 735232, 480000, 462300], "commentCharDensities": [0.0, 0.5533333333333333, 0.5634390651085142, 0.26298960831334933, 0.5629955947136563, 0.0, 0.07177033492822966, 0.0, 0.1412037037037037, 0.0, 0.0, 0.0, 0.5210355987055016, 0.14182344428364688, 0.5138516532618409, 0.26483357452966716, 0.0, 0.21714285714285714, 0.020512820512820513], "commentLineDensities": [0.0, 0.08333333333333333, 0.2857142857142857, 0.17857142857142858, 0.3333333333333333, 0.0, 0.041666666666666664, 0.0, 0.125, 0.0, 0.0, 0.0, 0.25, 0.15, 0.35, 0.15, 0.0, 0.11764705882352941, 0.05], "avgVarLength": [2.5, 4.0, 5.6, 3.8, 3.4, 3.4, 2.4, 3.0, 3.0, 4.0, 3.25, 4.0, 2.4, 4.25, 11.25, 2.5, 3.0, 5.25, 4.0], "cyclomaticComplexity": [2, 4, 3, 3, 2, 6, 4, 5, 2, 5, 7, 5, 7, 7, 7, 6, 7, 2, 7]}, "5. Longest Palindromic Substring": {"dimensions": [{"first": 1800, "second": 930}, {"first": 1800, "second": 930}, {"first": 1100, "second": 904}, {"first": 1493, "second": 1094}, {"first": 2083, "second": 1094}, {"first": 1900, "second": 1080}, {"first": 1600, "second": 1024}, {"first": 1800, "second": 930}, {"first": 2300, "second": 1024}, {"first": 1834, "second": 1046}, {"first": 963, "second": 858}, {"first": 1440, "second": 1038}, {"first": 2216, "second": 864}, {"first": 1333, "second": 1101}, {"first": 991, "second": 564}, {"first": 1919, "second": 794}, {"first": 1919, "second": 794}, {"first": 1343, "second": 593}, {"first": 1665, "second": 878}, {"first": 2186, "second": 580}], "memory_performance": [8.1, -1, -1, 22.7, -1, 8.4, -1, 6.9, 8.6, 8.4, 15.7, 35.2, 9.3, 11.1, 295.6, -1, -1, 6.8, -1, -1], "time_performance": [123.0, -1, -1, 205.0, -1, 7.0, -1, 196.0, 7.0, 10.0, 30.0, 265.0, 30.0, 8.0, 195.0, -1, -1, 7.0, -1, -1], "wpm": [58, 67, 91, 77, 101, 73, 77, 92, 74, 82, 61, 82, 79, 80, 78, 101, 98, 75, 51, 115], "success_state": [true, false, false, true, false, true, false, true, true, true, true, true, true, true, true, false, false, false, false, false], "testcases_passed": [141, 12, 72, 141, 0, 141, 74, 141, 141, 78, 141, 141, 141, 141, 141, 61, 36, 36, 141, 90], "runtimerelativescore": [51.01, -1, -1, 41.12, -1, 96.77, -1, 42.06, 96.77, 94.24, 64.93, 38.38, 64.93, 95.74, 45.49, -1, -1, 97.07, -1, -1], "memoryrelativescore": [61.71, -1, -1, 32.56, -1, 59.89, -1, 91.08, 59.58, 60.98, 49.6, 28.78, 59.74, 58.29, 9.68, -1, -1, 90.52, -1, -1], "user_sourcecode": ["#include <string>class Solution {public:    string longestPalindrome(string s) {        int n = s.size();        int start = 0;        int max_len = 0;        // Use a 2D table to store whether each substring is a palindrome or not        bool table[n][n];        memset(table, false, sizeof(table));        for (int i = 0; i < n; i++) {            table[i][i] = true;            max_len = 1;        }        for (int i = 0; i < n-1; i++) {            if (s[i] == s[i+1]) {                table[i][i+1] = true;                start = i;                max_len = 2;            }        }        for (int k = 3; k <= n; k++) {            for (int i = 0; i < n-k+1; i++) {                int j = i + k - 1;                if (table[i+1][j-1] && s[i] == s[j]) {                    table[i][j] = true;                    if (k > max_len) {                        start = i;                        max_len = k;                    }                }            }        }        return s.substr(start, max_len);    }};", "class Solution {public:    string longestPalindrome(string s) {        string max_palindrome;        int max_length = 0;        //cycle through        for (int i = 0; i < s.length(); i++) {            for (int j = i + 1; j <= s.length(); j++) {                string substring = s.substr(i, j - i);                int length = substring.length();                bool is_palindrome = true;                for (int k = 0; k < length / 2; k++) {                    if (substring[k] != substring[length - k - 1]) {                        is_palindrome = false;                        break;                    }                }                if (is_palindrome && length > max_length) {                    max_palindrome = substring;                    max_length = length;                }            }        }        return max_palindrome;    }};", "class Solution {public:    string longestPalindrome(string s) {        string max_palindrome;        int max_length = 0;        for (int i = 0; i < s.length(); i++) {            for (int j = i + 1; j <= s.length(); j++) {                string substring = s.substr(i, j - i);                int length = substring.length();                // Check if the current substring is a palindrome                bool is_palindrome = is_palindrome_help(substring);                // Update max_palindrome and max_length if the current substring is a longer palindrome                if (is_palindrome && length > max_length) {                    max_palindrome = substring;                    max_length = length;                }            }        }        // Return the longest palindromic substring found        return max_palindrome;    }    bool is_palindrome_help(string s) {        // Check through the helper         for (int i = 0; i < s.length() / 2; i++) {            if (s[i] != s[s.length() - i - 1]) {                return false;            }        }        return true;    }};", "class Solution {public:    string longestPalindrome(string s) {        int n = s.length();        if (n < 2) {            return s;        }        vector<vector<bool>> dp(n, vector<bool>(n, false));        int start = 0, end = 0;        // Initialize dp table for substrings of length 1 and 2        for (int i = 0; i < n; i++) {            dp[i][i] = true;            if (i < n - 1 && s[i] == s[i + 1]) {                dp[i][i + 1] = true;                start = i;                end = i + 1;            }        }        // Update dp table for substrings of length 3 or more        for (int len = 3; len <= n; len++) {            for (int i = 0; i <= n - len; i++) {                int j = i + len - 1;                if (s[i] == s[j] && dp[i + 1][j - 1]) {                    dp[i][j] = true;                    start = i;                    end = j;                }            }        }        return s.substr(start, end - start + 1);    }};", "class Solution {public:    string longestPalindrome(string s) {        string longest_palindrome;        int longest_palindrome_length = 0;        // Loop over all possible substrings of the input string        for (int i = 0; i < s.length(); i++) {            for (int j = i + 1; j <= s.length(); j++) {                string substring = s.substr(i, j - i);                int substring_length = substring.length();                bool is_palindrome = true;                for (int k = 0; k < substring_length / 2; k++) {                    if (substring[k] != substring[substring_length - k - 1]) {                        is_palindrome = false;                        break;                    }                }                if (is_palindrome && substring_length > longest_palindrome_length) {                    longest_palindrome = substring;                    longest_palindrome_length = substring_length;                }            }        }        string reverse_palindrome = longest_palindrome;        reverse(reverse_palindrome.begin(), reverse_palindrome.end());        // Concatenate         string concatenated_palindrome = longest_palindrome + reverse_palindrome;        for (int i = 0; i < concatenated_palindrome.length(); i++) {            if (concatenated_palindrome[i] == 'a') {                concatenated_palindrome[i] = 'b';            }        }        return concatenated_palindrome;    }};", "class Solution {public:    string longestPalindrome(string s) {        int n = s.length();        if (n < 2) {            return s;        }        // Preprocess the input string to include special characters        string processed_str = preProcess(s);        n = processed_str.length();        int center = 0, right = 0;        vector<int> palindrome_lengths(n, 0);        // Calculate palindrome lengths for each character in the processed string        for (int i = 1; i < n - 1; i++) {            int mirror = 2 * center - i;            // Check if current character is within the right boundary of the current center            if (i < right) {                // If so, use mirror palindrome length and update current palindrome length                palindrome_lengths[i] = min(right - i, palindrome_lengths[mirror]);            }            // Expand the palindrome around the current character            while (processed_str[i + palindrome_lengths[i] + 1] == processed_str[i - palindrome_lengths[i] - 1]) {                palindrome_lengths[i]++;            }            // Update center and right boundary if current palindrome extends past current right boundary            if (i + palindrome_lengths[i] > right) {                center = i;                right = i + palindrome_lengths[i];            }        }        // Find the longest palindrome length and center        int max_length = 0, max_center = 0;        for (int i = 1; i < n - 1; i++) {            if (palindrome_lengths[i] > max_length) {                max_length = palindrome_lengths[i];                max_center = i;            }        }        // Calculate start and end indices of the longest palindromic substring in the original string        int start = (max_center - max_length) / 2;        return s.substr(start, max_length);    }private:    string preProcess(string s) {        int n = s.length();        string processed_str = \"^#\";        // Add special characters to the processed string        for (int i = 0; i < n; i++) {            processed_str += s[i];            processed_str += \"#\";        }        processed_str += \"$\";        return processed_str;    }};", "class Solution {public:    string longestPalindrome(string s) {        string longest = \"\";        for (int i = 0; i < s.length(); i++) {            string temp = expand(s, i, i);            if (temp.length() > longest.length()) {                longest = temp; //global update here            }        }        return longest;    }private:    //helper to do 2P style between a set of indices    string expand(string s, int left, int right) {        while (left >= 0 && right < s.length() && s[left] == s[right]) {            left--;            right++;        }        return s.substr(left + 1, right - left - 1);    }};", "class Solution {public:    string longestPalindrome(string s) {        int n = s.length();                //lambda to two point invoked in one pass        auto is_palindrome = [&](int left, int right) { //takes in no initials, standard lambda format on C++            while (left < right) {                if (s[left++] != s[right--]) {                    return false;                }            }            return true;        };        string longest = \"\";        for (int i = 0; i < n; i++) { //invoke the lambda at each pair of indices            for (int j = n - 1; j >= i; j--) {                if (j - i + 1 <= longest.length()) {                    break;                }                if (is_palindrome(i, j)) {                    longest = s.substr(i, j - i + 1);                    break;                }            }        }        return longest;    }};", "class Solution {public:    string longestPalindrome(string s) {        if (s.empty()) {            return \"\";        }        int n = s.length();        string str = preProcess(s); // Preprocess the input string        int m = str.length();        vector<int> p(m, 0); // Array to store the lengths of the palindromic substrings        int center = 0, right = 0; // Center and right boundary of the current palindrome        // Manacher's algorithm to calculate palindromic substring lengths        for (int i = 1; i < m - 1; i++) {            int mirror = 2 * center - i;            // Check if current character is within the right boundary of the current center            if (i < right) {                // If so, use mirror palindrome length and update current palindrome length                p[i] = min(right - i, p[mirror]);            }            // Expand the palindrome around the current character            while (str[i + p[i] + 1] == str[i - p[i] - 1]) {                p[i]++;            }            // Update center and right boundary if current palindrome extends past current right boundary            if (i + p[i] > right) {                center = i;                right = i + p[i];            }        }        // Find the longest palindrome length and center        int max_len = 0, max_idx = 0;        for (int i = 1; i < m - 1; i++) {            if (p[i] > max_len) {                max_len = p[i];                max_idx = i;            }        }        // Calculate start index of the longest palindromic substring in the original string        int start = (max_idx - max_len - 1) / 2;        return s.substr(start, max_len); // Return the longest palindromic substring    }private:    string preProcess(string s) {        int n = s.length();        if (n == 0) {            return \"^$\";        }        string str = \"^\";        for (int i = 0; i < n; i++) {            str += \"#\" + s.substr(i, 1);        }        str += \"#$\";        return str;    }};", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0string preprocess(string s) {\n \u00a0 \u00a0 \u00a0 \u00a0int n = s.size();\n \u00a0 \u00a0 \u00a0 \u00a0if (n == 0) return \"^$\";\n \u00a0 \u00a0 \u00a0 \u00a0string ret = \"^\";\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i < n; i++)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ret += \"#\" + s.substr(i, 1);\n \u00a0 \u00a0 \u00a0 \u00a0ret += \"#$\";\n \u00a0 \u00a0 \u00a0 \u00a0return ret;\n \u00a0  }\n\u200b\n \u00a0 \u00a0string longestPalindrome(string s) {\n \u00a0 \u00a0 \u00a0 \u00a0//using manacher's let's me bring this down from O(N^3) to near linear time\n \u00a0 \u00a0 \u00a0 \u00a0string T = preprocess(s);\n \u00a0 \u00a0 \u00a0 \u00a0//call the helper function to get substring where needed, inserting spots to change the window\n \u00a0 \u00a0 \u00a0 \u00a0int n = T.size();\n \u00a0 \u00a0 \u00a0 \u00a0vector<int> P(n);\n \u00a0 \u00a0 \u00a0 \u00a0int C = 0, R = 0;\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 1; i < n - 1; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//while we are still in the string, get the window and check mirror update\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int i_mirror = 2 * C - i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (R > i) P[i] = min(R - i, P[i_mirror]);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0else P[i] = 0;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0while (T[i + 1 + P[i]] == T[i - 1 - P[i]]) P[i]++;\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (i + P[i] > R) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0C = i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0R = i + P[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0int max_len = 0;\n \u00a0 \u00a0 \u00a0 \u00a0int center_index = 0;\n \u00a0 \u00a0 \u00a0 \u00a0for (int i = 1; i < n - 1; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (P[i] > max_len) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//update the max length accordingly\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0max_len = P[i];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0center_index = i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//the center corresponds to wherever the updated index hits\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0return s.substr((center_index - 1 - max_len) / 2, max_len);\n \u00a0  }\n\u200b\n\u200b\n};\n\u200b", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0string longestPalindrome(string s) \n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0int lenMax = 0;\n \u00a0 \u00a0 \u00a0 \u00a0string res;\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0for(int i=0; i<s.length(); i++)\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0long_subs(odd, res, lenMax);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0long_subs(even, res, lenMax);\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return res;\n \u00a0  }\n    \n    string pali_subs(string &s, int L, int R)\n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0int n=s.size();\n \u00a0 \u00a0 \u00a0 \u00a0while(L>=0 && R<n) //iterate until L and R cross the boundary\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(s[L]!=s[R]) break;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0L--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0R++;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return s.substr(L+1, R-1-L); //return palindromic substring\n \u00a0  }\n \u00a0 \u00a0\n \u00a0 \u00a0void long_subs(string &new_s, string &res, int &lenMax)\n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0if(new_s.size()>lenMax) //check if we're within the max length so far\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0res = new_s;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0lenMax = new_s.size();\n \u00a0 \u00a0 \u00a0  }\n \u00a0  } \u00a0\n}; ", "class Solution {\npublic:\n \u00a0 \u00a0string longestPalindrome(string s) \n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0int lenMax = 0;\n \u00a0 \u00a0 \u00a0 \u00a0string res;\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0for(int i=0; i<s.length(); i++)\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0long_subs(odd, res, lenMax);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0long_subs(even, res, lenMax);\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return res;\n \u00a0  }\n    \n    string pali_subs(string &s, int L, int R)\n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0int n=s.size();\n \u00a0 \u00a0 \u00a0 \u00a0while(L>=0 && R<n) //iterate until L and R cross the boundary\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(s[L]!=s[R]) break;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0L--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0R++;\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0return s.substr(L+1, R-1-L); //return palindromic substring\n \u00a0  }\n \u00a0 \u00a0\n \u00a0 \u00a0void long_subs(string &new_s, string &res, int &lenMax)\n \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0if(new_s.size()>lenMax) //check if we're within the max length so far\n \u00a0 \u00a0 \u00a0  {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0res = new_s;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0lenMax = new_s.size();\n \u00a0 \u00a0 \u00a0  }\n \u00a0  } \u00a0 \n}; ", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0string longestPalindrome(string s) {\n \u00a0 \u00a0 \u00a0 \u00a0int n =s.length();\n \u00a0 \u00a0 \u00a0 \u00a0string str;\n \u00a0 \u00a0 \u00a0 \u00a0int ans = 0;\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0//2pointer method because otherwise we would have to create a 2D matrix risking o(N^2) mem complexity\n \u00a0 \u00a0 \u00a0 \u00a0\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0for(int i=0;i<s.length();i++){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int left=i,right=i+1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// if length is even\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//we decrement and increment the pointers accordingly\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while(left>=0 \u00a0&& right<s.length() && \u00a0s[left]==s[right] ){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0left--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0right++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0left++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 right--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int length = right-left+1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if(ans<length){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans=length;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cout<<left<<\" \"<<right;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 str = s.substr(left, right-left+1);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0left=i,right=i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// if length is odd\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//do the same thing\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while(left>=0 && right<s.length() && s[left]==s[right]){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0left--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0right++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 left++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 right--;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 length = right-left+1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 if(ans<length){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans=length;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 str = s.substr(left, right-left+1);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0\n \u00a0 \u00a0 return str;\n \u00a0  }\n};", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0string longestPalindrome(string s) {\n \u00a0 \u00a0 \u00a0 int oddans=0, evenans=0, n=s.size();\n \u00a0 \u00a0 \u00a0 \u00a0//if we apply the binary search here we can avoid the excess, sacrifice some memory complexity though\n \u00a0 \u00a0 \u00a0 string so, se;\n \u00a0 \u00a0 \u00a0 for(int i=0; i<n; i++){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //test here on the first pass\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int cur=1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int st=i-1, e=i+1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while(st>=0 and e<n and s[st]==s[e]){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cur+=2;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 st--, e++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 \u00a0if(cur>oddans){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//update palindrome at odd indices\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0oddans = cur;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0so = s.substr(i-cur/2,cur);\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 for(int i=1; i<n; i++){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //do an extra pass but for even indices\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int cur=0;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 int st=i-1, e=i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while(st>=0 and e<n and s[st]==s[e]){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 //same update process as before\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 cur+=2;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 st--, e++;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0 \u00a0 \u00a0if(cur>evenans){\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0evenans = cur;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0se = s.substr(i-cur/2,cur);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//update even based window palindrome and compare\n \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 }\n \u00a0 \u00a0if(evenans>oddans) \u00a0return se;\n \u00a0 \u00a0return so;\n \u00a0  }\n}; ", "\u00a0\nclass Solution {\npublic:\n \u00a0 \u00a0 \u00a0 string longestPalindrome(string s) { \u00a0\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int n = s.size() ; \n \u00a0\n\u200b\n \u00a0 \u00a0vector<vector<int>> dp(n+10,vector<int>(n+10,0)) ; \n\u200b\n\u200b\n \u00a0 \u00a0int ans = 0 ; string f = \"\" ; \n\u200b\n \u00a0 \u00a0if(n==1) return s ; \n \u00a0 \u00a0\n\u200b\n \u00a0 \u00a0int x = 0 , y = 0 ; \n\u200b\n\u200b\n \u00a0 \u00a0string t = s ; reverse(t.begin(),t.end()) ; if(s==t)return s ;\n\u200b\n \u00a0 \u00a0for( int i = 0 ; i<n ; i++ ) dp[i][i]=1 ;\n \u00a0 \u00a0\n \u00a0 \u00a0for (int i = 0; i < n - 1; ++i) {\n \u00a0 \u00a0 \u00a0 \u00a0if (s[i] == s[i + 1]) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0dp[i][i + 1] = 2;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 x = i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 y = i+1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 ans = 2 ;\n \u00a0 \u00a0  }\n \u00a0 \u00a0  }", "class Solution {\npublic:\nstring longestPalindrome(string s) {\n \u00a0 \u00a0int len = s.length();\n \u00a0 \u00a0for(int i = len; i >= 0; i--) {\n \u00a0 \u00a0 \u00a0 \u00a0for(int j = 0; j <= len - i; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string substring = s.substr(j, i);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string reversed_substring = substring;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0reverse(reversed_substring.begin(), reversed_substring.end());\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//iterate and revsere on each window point\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(substring == reversed_substring) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return substring;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0  }\n \u00a0 \u00a0return \"\";\n}\n}; ", "\u00a0\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\n \u00a0 \u00a0int len = s.length();\n \u00a0 \u00a0for(int i = len; i > 0; i--) {\n \u00a0 \u00a0 \u00a0 \u00a0for(int j = 0; j < len - i; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string substring = s.substr(j, i);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string reversed_substring = substring;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0reverse(reversed_substring.begin(), reversed_substring.end());\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//trying again but varying index\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if(substring == reversed_substring) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return substring;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0  }\n \u00a0 \u00a0return \"\";\n}\n}; \u00a0", "\u00a0\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\n \u00a0 \u00a0int len = s.length();\n \u00a0 \u00a0int start = 0, maxLen = 1;\n\u200b\n \u00a0 \u00a0for (int i = 0; i < len;) {\n \u00a0 \u00a0 \u00a0 \u00a0//uhhhhhhh idk tbh\n \u00a0 \u00a0 \u00a0 \u00a0if (len - i <= maxLen / 2) break;\n \u00a0 \u00a0 \u00a0 \u00a0//check still in bounds\n \u00a0 \u00a0 \u00a0 \u00a0int j = i, k = i;\n \u00a0 \u00a0 \u00a0 \u00a0while (k < len-1 && s[k+1] == s[k]) ++k; \n \u00a0 \u00a0 \u00a0 \u00a0i = k+1;\n \u00a0 \u00a0 \u00a0 \u00a0//iterate accordingly\n \u00a0 \u00a0 \u00a0 \u00a0while (k < len-1 && j > 0 && s[k+1] == s[j-1]) { ++k; --j; } \n \u00a0 \u00a0 \u00a0 \u00a0int newLen = k - j + 1;\n \u00a0 \u00a0 \u00a0 \u00a0if (newLen > maxLen) { start = j; maxLen = newLen; }\n \u00a0  }\n \u00a0 \u00a0return s.substr(start, maxLen);\n}\n}; \u00a0 ", "\u00a0\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\n \u00a0 \u00a0string longest = \"\";\n \u00a0 \u00a0int n = s.length();\n\u200b\n \u00a0 \u00a0for (int i = 0; i < n; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (int j = i; j < n; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string substr = s.substr(i, j - i + 1);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0string rev = substr;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0reverse(rev.begin(), rev.end());\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (substr == rev && substr.length() > longest.length()) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0longest = substr;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0  }\n\u200b\n \u00a0 \u00a0return longest;\n} \u00a0\n}; \u00a0 \u00a0", "\u00a0\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\n \u00a0 \u00a0int maxLength = 0;\n \u00a0 \u00a0int start = 0;\n \u00a0 \u00a0int n = s.length();\n\u200b\n \u00a0 \u00a0for (int i = 0; i < n; i++) {\n \u00a0 \u00a0 \u00a0 \u00a0for (int j = i; j < n; j++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0bool isPalindrome = true;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//update on pass\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int k = i; k <= j; k++) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (s[k] != s[i + j - k]) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//if ends of the window consistently don't match update to fals\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0isPalindrome = false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0break;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n\u200b\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (isPalindrome && (j - i + 1) > maxLength) {\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0maxLength = j - i + 1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0start = i;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  }\n \u00a0 \u00a0 \u00a0  }\n \u00a0  }\n\u200b\n \u00a0 \u00a0return s.substr(start, maxLength);\n} \u00a0\n}; \u00a0 \u00a0"], "autocomplete": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "language": ["C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++", "C++"], "backspaceCount": [6, 16, 14, 5, 8, 4, 23, 15, 0, 32, 8, 42, 15, 4, 8, 50, 59, 18, 41, 33], "tabCount": [3, 5, 6, 8, 12, 12, 5, 6, 6, 6, 7, 5, 9, 3, 10, 10, 9, 4, 10, 11], "usefulnessIndex": [0.33333333333, 0, 0.16666666666, 0.25, 0.25, 0.58333333333, 0.2, 0.33333333333, 0.83333333333, 0.5, 0.571428571, 0.14285714285714285, 0.66666666666, 0.9, 0.6, 0.1, 0, 0.75, 0.4, 0.454545455], "totalPixels": [1674000, 1674000, 994400, 1633342, 2278802, 2052000, 1638400, 1674000, 2355200, 1918364, 826254, 1494720, 1914624, 1467633, 558924, 1523686, 1523686, 796399, 1461870, 1267880], "commentCharDensities": [0.06445182724252492, 0.03013481363996828, 0.27241139680333565, 0.11487481590574374, 0.09020618556701031, 0.40620328849028403, 0.15613382899628253, 0.20510774142059057, 0.411601112435439, 0.2582236842105263, 0.25019607843137254, 0.25019607843137254, 0.23563892145369286, 0.25930764206401047, 0.0, 0.12330623306233063, 0.11126373626373626, 0.2214199759326113, 0.0, 0.13219424460431656], "commentLineDensities": [0.023255813953488372, 0.03125, 0.11764705882352941, 0.05405405405405406, 0.047619047619047616, 0.17307692307692307, 0.08695652173913043, 0.09090909090909091, 0.18518518518518517, 0.11627906976744186, 0.15625, 0.15625, 0.07692307692307693, 0.15789473684210525, 0.0, 0.045454545454545456, 0.045454545454545456, 0.11538461538461539, 0.0, 0.06451612903225806], "avgVarLength": [2.5555555555555554, 5.333333333333333, 7.142857142857143, 2.0, 8.285714285714286, 3.5555555555555554, 3.3333333333333335, 2.4, 3.0, 3.6666666666666665, 2.0, 2.0, 3.0, 2.5714285714285716, 1.4, 1.6666666666666667, 1.6666666666666667, 3.2, 1.0, 4.285714285714286], "cyclomaticComplexity": [2, 3, 3, 4, 3, 3, 2, 2, 5, 14, 6, 6, 4, 15, 7, 5, 5, 14, 6, 10]}}